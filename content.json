[{"title":"JWT 与 登录保持","date":"2018-07-31T05:25:35.000Z","path":"2018/07/31/JWT/","text":"1. JWT (JSON Web Token)JWT 是一种建立在 JSON 上的验证方式，目的是通过发放 token，让API资源被信任的用户访问。JWT 最大的特点是无状态，服务器创建 token 并返回给浏览器后，浏览器之后的访问都要带上这个 token，服务器并不存储 token 的信息，所以在分布式服务和大规模用户访问上更有优势。 具体可参考阮一峰老师对JWT的介绍, 下面主要谈一下登录保持。 2. 登录保持2.1 需求 用户通过帐号和密码登录，登录后在很长一段时间（e.g. 3天）内可以保持登录状态。即使用户关闭浏览器后，在若干小时后打开页面依然可以直接进入服务，而不需要重新登录。当用户隔较长时间（e.g. &gt;3天）未登录时，再次登录需要重新输入帐号和密码。 2.2 思路 使用单个 token 每次传到服务器时，判断一下过期时间。例如有效时间是3天，当检测到还剩1h token 就要失效时，就将创建一个新 token 返回给浏览器 存在的问题： 由于要实现3天内免登录，token的有效时间就要设为3天。较长的有效时间带来了较低的安全性。 剩余时间难以预测。假如设定的剩余时间是1h，用户很小概率恰好在失效前的最后一小时还在使用服务。 使用accessToken与refreshToken accessToken用来进行访问控制，它的有效时间很短，安全性更好。 refreshToken用来更新accessToken，它的有效时间很长。 当accessToken过期时，就用refreshToken重新获取accessToken。 当refreshToken也过期时，就需要重新登录。 优点：因为refreshToken存储在服务器中，所以管理人员可以删除某个refreshToken来剔除恶劣用户。 缺点：失去了无状态，服务器需要存储refreshToken。 2.3 实现 为了简化表述，存储改为在内存中存储，生产环境中请使用数据库 启动一个 nodejs 服务器，这里使用Koa框架。 123const Koa = require('koa');const app = new Koa();app.listen(3000); 初始化登录路由，获得用户名和密码后，向浏览器发放accessToken和refreshToken。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Koa = require('koa');const app = new Koa();/* 下面是增加的代码 */const bodyParser = require('koa-bodyparser');const Router = require('koa-router')const jwt = require('jsonwebtoken');const jwtKoa = require('koa-jwt');let randtoken = require('rand-token');const util = require('util');const verify = util.promisify(jwt.verify);let refreshTokens = new Map();const secret = 'jwt_demo';const router = new Router();app.use(bodyParser());app.use(jwtKoa(&#123;secret&#125;).unless(&#123; path: [/^\\/api\\/login/, /^\\/api\\/token/] /* 排除/api/login 路径 和/api/token 路径 */&#125;));router.post('/api/login', async(ctx, next) =&gt; &#123; const user = ctx.request.body; if (user &amp;&amp; user.name) &#123; let info = &#123; name: user.name &#125;; const accessToken = jwt.sign(info, secret, &#123; expiresIn: '15m'&#125;); /* 生成accessToken，有效期为15分钟 */ const refreshToken = randtoken.uid(16); /* 获取16位refreshToken */ refreshTokens.set(refreshToken, user.name); ctx.response.body = &#123; accessToken: accessToken, refreshToken: refreshToken &#125;; &#125;&#125;)app.use(router.routes()) .use(router.allowedMethods());/* 新增代码到此结束 */app.listen(3000); 初始化accessToken刷新路由。浏览器发送refreshToken，服务器验证如果map中持有该refreshToken且对应的username与发送过来的username匹配，那么就发送新的token。否则返回401错误状态。 12345678910111213141516router.post('/api/token', async (ctx, next) =&gt; &#123; const username = ctx.request.body.name; const refreshToken = ctx.request.body.refreshToken; if (refreshTokens.has(refreshToken) &amp;&amp; refreshTokens.get(refreshToken) === username) &#123; let info = &#123; name: username &#125;; let accessToken = jwt.sign(info, secret, &#123; expiresIn: '15m' &#125;); ctx.body = &#123; accessToken: accessToken &#125; &#125; else &#123; /* 401 没有权限访问，需要重新登录 */ ctx.throw(401); &#125;&#125;); 初始化一个保护的资源访问路径 12345678910111213router.get('/api/secret', async (ctx, next) =&gt; &#123; const token = ctx.header.authorization; /* 获得accessToken */ if (token) &#123; let accessToken = token.split(' ')[1]; let accessPayload = await verify(accessToken, secret); /* 解密，获取accessPayload */ ctx.body = \"It's a secret.\"; &#125; else &#123; ctx.body = &#123; message: 'token 错误', code: -1 &#125;; &#125;&#125;); 2.4 验证 用name登录，获取一个accessToken 1curl -d \"name=foo\" http://127.0.0.1:3000/api/login 返回值如下（不一定全部相同）： 1&#123;\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\",\"refreshToken\":\"SPeAsKMcbHqjBrQ5\"&#125; 不带token访问保护资源 1curl http://127.0.0.1:3000/api/secret 返回值如下： 1Authentication Error 带token访问保护资源 1curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\" http://127.0.0.1:3000/api/secret 返回值如下： 1It&apos;s a secret. 15分钟后带token访问保护资源 1curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\" http://127.0.0.1:3000/api/secret 返回值如下： 1Authentication Error 用refreshToken换accessToken 1curl -d \"name=foo&amp;refreshToken=3VqXxVFaFequGZEt\" http://127.0.0.1:3000/api/token 返回值如下： 1&#123;\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEzNzIwLCJleHAiOjE1MzMwMTQ2MjB9.5-w9P4AY033GaW77azsd6-mBMOxMMIhaqgMph_tOHpw\"&#125; refreshToken的失效可以通过数据库的updateTime来判断，如果currentTime - updateTime &gt; 3day，那么就不派发新的accessToken，并且删除旧的refreshToken记录，要求重新登录。 2.5 改进每次都要在请求头中加入token，不方便。accessToken失效，需要手动换取新的accessToken，也不方便。 因此最好有一种代理机制，能在每次发请求和收到请求时做一些处理。下面使用axios的请求拦截器来实现。 1234567cdn 引入： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;npm 引入:npm install vuenpm install axios 请求拦截，添加Authorization。 12345678axios.interceptors.request.use(config =&gt; &#123; if (localStorage.accessToken) &#123; config.headers.Authorization = 'Beared ' + localStorage.accessToken; &#125; return config;&#125;, err =&gt; &#123; return Promise.reject(err);&#125;) 响应拦截，处理token刷新 123456789101112131415161718192021222324axios.interceptors.response.use(async res =&gt; &#123; /* 处理token过期 */ /* 如果code === -1，表示token无效，需要刷新 */ if (res.data.code === -1) &#123; await axios.post('/api/token', &#123; name: localStorage.username ? localStorage.username : '', refreshToken: localStorage.refreshToken ? localStorage.refreshToken : '' &#125;).then(async res2 =&gt; &#123; /* 将返回的新token存起来 */ localStorage.setItem('accessToken', res2.data.accessToken); /* 再次发送之前因为token过期而失败的请求 */ let &#123; method, url, data &#125; = res.config; await axios[method](url, data).then((res3)=&gt; &#123; res = res3; /* 将失败的请求响应换成成功的请求响应 */ &#125;) &#125;).catch((err) =&gt; &#123; this.authenticated = false; /* 如果refreshToken也失败，那就要重新登录 */ &#125;) &#125; return res;&#125;, function (error) &#123;return Promise.reject(error);&#125;); Vue 文件 1234567891011121314151617181920212223242526272829data()&#123; return &#123; username: '', password: '', authenticated: true, secret: '' &#125;&#125;,methods: &#123; login() &#123; const &#123; username, password &#125; = this; axios.post('/api/login', &#123; name: username &#125;).then(res =&gt; &#123; localStorage.setItem('username', this.username); localStorage.setItem('accessToken', res.data.accessToken); localStorage.setItem('refreshToken', res.data.refreshToken); this.authenticated = true; this.getSecret(); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;) &#125;, getSecret() &#123; axios.get('/api/secret').then(res =&gt; &#123; this.secret = res.data &#125;) &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"2017","date":"2017-12-27T08:05:09.000Z","path":"2017/12/27/2017/","text":"January穷游杭州 很幸运订到一家很漂亮的民宿，刷新了我对青年旅舍的理解 一起吃兰州拉面，玩桌游 三小时徒步西湖，雷锋塔顶看日落夕阳 深夜12点还在杭州的路上瞎逛，“和我在杭州的街头走一走，哦~~，直到所有的灯都熄灭了也不停留” Blog 1.0March 鸡鸣寺看樱花，一个人逛玄武湖，带上耳机净化心灵 May iPhone 5 -&gt; iPhone 7 终于换手机啦，原来的iPhone 5屏幕实在是太小了，而且容量也不够大，换了 7 之后，异常流畅，不够据说Cook又给7的CPU降频了，打死也不更新系统了（更新了ios 11，有一次突然要我同意一份协议，然后莫名其妙升级了） Sister Married emmmmmm不能常见面了呢 最美好时光就是除夕夜一起放烟花了吧，今年放烟花恐怕只有我一人了 爸爸把姐姐搀上台的一刻感动哭了 June Manchester by the Sea 年度电影，一部很丧的电影，看完却很治愈 一个沉默的灵魂背后，永远不知道他背负了怎样的生死离别 July Driver‘s license 科目三考试遇上台风天气，我的车技是受过考验的 第一次4：30起床 August Teaching in Anhui 在霍邱支教，又体验了一下农村的生活，仿佛一下子回到2003年我刚上小学那会儿 十多天，每天六点起，十一点睡，吃相同的饭，做不同的事，能坚持下来，要谢谢一起支教的同学 September New semester 选了很多课，想做很多事，背负了更多的责任，可时间有限，觉得很累 October Mountain climbing 一起爬了东盘山 第二次4：30起床 山底下的生煎和紫菜汤真的很好吃！！ 富游南京 南京人生无限公司 其实我就是个地陪 坐在老门东的台阶上，一起“换脸” 来了南京之后，一直没去的夫子庙，商业气息很重，晚上的灯光景色也非常的商业化 在酒店里吃火锅，做饭（主要是煎蛋啦），玩大富翁玩到凌晨3点（我真的怕自己猝死） 最好的朋友就是可以一起大哭一起大笑吧，和你们在一起是我最放松最自我的状态 November Blog 2.0 在学习Vue 2.0 ，觉得教程的网页样式很好看，想做成博客，没想到真的有和我一样想法的人 When the wind blows 年度音乐，治愈系的声音 The Year 有的时候为别人考虑太多，反而伤害了自己 有的时候太犹豫不决，唯唯诺诺，错过了很多机会 有的时候想做，却没有几分钟热度 有的时候想做，又不敢做 注重体验生活的一年，去支教是我意料之外的事情 2018 攒钱买一台MacBook Pro 不想让爸妈出钱，我也是有房贷在身的人了 MBP的系统和屏幕 原来的电脑硬盘太小了 做一个自己的前端项目 一直没有去实现一个自己的idea ✈成都&amp;重庆 一个赛博风格的城市 更加敢想敢做，Be yourself","tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"Sakura","date":"2017-03-25T11:00:09.000Z","path":"2017/03/25/sakura/","text":"今天去看了樱花，一个人走在樱花路上，看见家长们带着调皮的孩子，看见一长串身着绿色校服的中学生来春游，互相笑着，调侃着，追赶奔跑着，仿佛曾经的自己 最近消化道不太舒服，有时候想多睡一会儿，就少了吃饭的时间，满足了第一个大脑，第二个“大脑”也会抗议的吧。对于远离父母的大学生来说，得病应该是最忌讳的事情了，没有父母的照料，饮食上无法选择，就像是刚出生的婴儿一样，毫无招架之力","tags":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/tags/随想/"}]},{"title":"Hello Blog!","date":"2017-03-01T10:50:17.000Z","path":"2017/03/01/关于此博客/","text":"1.博客的诞生几天前在知乎上看见了一篇搭建博客的文章,寒假里也有搭建博客的想法，但是因为服务器和域名的门槛太高就搁置了，但是这篇文章中 hexo + github 的方法还是很简单的。 最重要的是可以自己设置界面，不像网易博客或者微博，有很大的自主权限。 2.项目中的技术github的使用，git版本控制和shell命令行模式的使用，HTML + CSS + JavaScript，SSH key，hexo框架，markdown。 2017.3.4 更新 markdown语法熟悉，老师要求需求等一系列文档用md格式 推荐编辑软件Typora 3.从项目中的收获因为有教程，一步一步来不会出太大差错。主要踩坑的地方就是_config.yml文件的配置。 1.图床。博客的头像以及文章中的图片都需要放置在云上，通过url获取，因为github空间有限制。 2.社交媒体的导航。也采用url的形式，例如weibo.com/username 3.打赏功能。收款的二维码图片在支付宝二维码平台获取 4.网站icon。favicon是网站的图标，应该放在source文件夹中。icon的大小为16 16或32 32。后缀名可以是ico或png，可以通过在线icon制作网站，如bitbug来转换。 5.github的使用。fork 别人的项目。 repository 代码仓库。pull request 提交代码请求","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]
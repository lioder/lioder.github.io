[{"title":"微服务从0开始(0)","date":"2019-05-07T12:07:45.000Z","path":"2019/05/07/microservice1/","text":"写在前面因为第二学期软件设计与体系结构课上一直在强调微服务，最后也设计了一个微服务的体系结构，但自己对微服务其实还是一知半解（别笑）。秉持的实践出真知的原则，我还是打算写一个微服务来全面理解一下。 下面列举了我在没有实践微服务之前主要的疑惑： RPC是什么，为什么服务之间不使用Rest和HTTP通信？ 服务注册和服务发现是什么？ 为什么要用NGINX？ Docker在微服务中有什么用？ CI和CD在微服务中怎样实践？ 正题 我学习微服务主要是用Go语言 首先解答问题1：RPC是什么，为什么服务之间不使用Rest和HTTP通信？ 如果使用Rest和HTTP，那么服务间传递数据是这样的： 服务A将数据encode成json字符串，通过ajax发送给服务B，服务B parse成对象 如果使用gRPC，那么服务间传递数据是这样的： 使用protobuf协议约定数据格式，服务A将数据转化为二进制数据流，基于HTTP 2.0 的二进制数据帧发送给服务B，服务B按照约定的格式parse成对象 微服务可以使用Rest和HTTP通信，但是多了encode和decode的步骤 最基本的微服务结构 先使用protobuf语法定义一个微服务以及他的方法，定义一系列消息对象 然后通过protobuf编译器编译成go语言文件，文件中包含了定义的消息结构体，一系列微服务方法以及接口 写一个service，实现上述接口 创建一个gRPC服务器，将我们的service与协议中的微服务绑定 写一个client，首先拨号连接到gRPC服务器，然后调用协议中的方法创建客户端，客户端可以调用协议中定义的微服务的各种方法 ![https://github.com/lioder/lioder.github.io/raw/master/images/microservice1.png) 从客户端出发来看，客户端先获取gRPC服务器的连接，然后通过.pb.go获得服务的调用器，之后就像调用本地方法一样使用 而service这边，创建了一个gRPC服务器，并将自己进行注册 参考这里只做一个梳理和记录，具体的实践代码可以参考：Golang 微服务教程（一）","tags":[{"name":"Microservice","slug":"Microservice","permalink":"http://yoursite.com/tags/Microservice/"}]},{"title":"Vue-diff-算法","date":"2019-03-04T15:16:20.000Z","path":"2019/03/04/Vue-diff-算法/","text":"Vue diff 算法在Vue中用virtual DOM来对应真实的DOM，每一个DOM节点用一个vnode表示。那么当数据更新时，如何知道哪些vnode需要更新呢？答案就是使用diff算法。 diff算法只按层级比较。 从什么时候开始patch？当数据通过set修改时，会调用闭包中的Dep，Dep通知所有注册的watcher进行更新。 更新方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this /*如果已经该组件已经挂载过了则代表进入这个步骤是个更新的过程，触发beforeUpdate钩子*/ if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. /*基于后端渲染Vue.prototype.__patch__被用来作为一个入口*/ if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance // update __vue__ reference /*更新新的实例对象的__vue__*/ if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. &#125; 方法第一个参数传入新的vnode，将旧的vnode赋值给preVnode，然后将新的vnode赋值给当前组件的vnode，然后执行vm.__patch__(prevVnode, vnode)。 怎么 patch？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*createPatchFunction的返回值，一个patch函数*/ return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) &#123; /*旧vode存在，新vnode不存在，就调用销毁的钩子函数*/ if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; // empty mount (likely as component), create new root element /*oldVnode未定义的时候，其实也就是root节点，创建一个新的节点*/ isInitialPatch = true createElm(vnode, insertedVnodeQueue, parentElm, refElm) &#125; else &#123; /*标记旧的VNode是否有nodeType*/ /*Github:https://github.com/answershuto*/ const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node /*是同一个节点的时候直接修改现有的节点*/ patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) &#125; else &#123; if (isRealElement) &#123; // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; /*当旧的VNode是服务端渲染的元素，hydrating记为true*/ oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; /*需要合并到真实DOM上*/ if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; /*调用insert钩子*/ invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' + 'full client-side render.' ) &#125; &#125; // either not server-rendered, or hydration failed. // create an empty node and replace it /*如果不是服务端渲染或者合并到真实DOM失败，则创建一个空的VNode节点替换它*/ oldVnode = emptyNodeAt(oldVnode) &#125; // replacing existing element /*取代现有元素*/ const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) if (isDef(vnode.parent)) &#123; // component root element replaced. // update parent placeholder node element, recursively /*组件根节点被替换，遍历更新父节点element*/ let ancestor = vnode.parent while (ancestor) &#123; ancestor.elm = vnode.elm ancestor = ancestor.parent &#125; if (isPatchable(vnode)) &#123; /*调用create回调*/ for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, vnode.parent) &#125; &#125; &#125; if (isDef(parentElm)) &#123; /*移除老节点*/ removeVnodes(parentElm, [oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; /*Github:https://github.com/answershuto*/ /*调用destroy钩子*/ invokeDestroyHook(oldVnode) &#125; &#125; &#125;js /*调用insert钩子*/ invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm &#125; 分为两种情况： sameNode和非sameNode 如何判断sameNode?两节点key相同，tag相同，同为注释节点或同不为注释节点，是否定义data，是否有相同的类型（当tag为input时） 1234567891011121314151617function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) )&#125;function sameInputType (a, b) &#123; if (a.tag !== 'input') return true let i const typeA = isDef(i = a.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type const typeB = isDef(i = b.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type return typeA === typeB&#125; patchVnode如果是sameVnode，就执行patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)。 12345678910111213141516171819202122232425262728const elm = vnode.elm = oldVnode.elm const oldCh = oldVnode.children const ch = vnode.children /*如果这个VNode节点没有text文本时*/ if (isUndef(vnode.text)) &#123; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; /*新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren*/ if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; /*如果老节点没有子节点而新节点存在子节点，先清空elm的文本内容，然后为当前节点加入子节点*/ if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; /*当新节点没有子节点而老节点有子节点的时候，则移除所有ele的子节点*/ removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; /*当新老节点都无子节点的时候，只是文本的替换，因为这个逻辑中新节点text不存在，所以直接去除ele的文本*/ nodeOps.setTextContent(elm, '') &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; /*当新老节点text不一样时，直接替换这段文本*/ nodeOps.setTextContent(elm, vnode.text) &#125; /*调用postpatch钩子*/ if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) &#125; 首先newVnode如果是文本节点，就直接将老的文本节点内容，换成新的文本节点内容。 如果不是，则要比较他们的children。 那么有四种情况： 新的有，老的也有 新的有，老的没有 新的没有，老的有 新的没有，老的也没有 先看最简单的，第四种。因为在这里newVnode不是文本节点，它又没有children，说明他是个空节点，那就删除旧节点的内容。 然后看第三种。新的没有，老的有，那就把老的节点内容都删了。 删除的调用是：removeVnodes(elm, oldCh, 0, oldCh.length - 1) removeVnodes是一个批量删除节点的方法，参数含义分别是父元素，vnodes列表，开始索引和结束索引，其实有用的是后三个。调用时会把从0~oldCh.length-1的vnode取出来，然后通过vnode.elm获得真实的DOM元素，然后通过nodeOps（一层DOM操作API封装）去删除真实的节点。 然后再看第二种。新的有，老的没有。那就把老的节点内容清空，然后加入新的节点内容。 增加的调用是：addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) addVnodes是一个批量增加节点的方法，参数含义分别是，父元素，ref元素（不为null的话表示指定插在它前面），插入的vnodes列表，开始索引，结束索引。 addVnodes内部会调用createElm创建真实dom节点，然后append在父元素下 最后是第一种，新的有老的也有。那就要比较他们的children了。 updateChildrenchildren分为老的children和新的children，分别为这两队children设置头尾指针，称为oldStartIdx,oldEndIdx,newStartIdx和newEndIdx。 两两比较，四种情况： 老头=新头 老头=新尾 新头=老尾 新尾=老尾 第一种情况，直接patchVnode（又回到四种的情况），新头++，老头++。 第二种情况，patchVnode，同时将老头放到老尾后。老头++，新尾–。 第三种情况，patchVnode，同时将老尾放到老头前。新头++，老尾–。 第四种情况，直接patchVnode。老尾–，新尾–。 如果以上情况都不符合。那么会从map中去找，map是一个以oldVnode的key为key，index为value的map。 先取出newStartIdx对应的vnode，获得它的key，然后去map里看有没有这个key，如果有的话，patchVnode并移动DOM节点。移动的方式是将这个oldVnode节点移到oldStartIdx对应的节点前。然后newStartIdx++。如果没有对应的key的话，会创建一个新的节点，插入到oldStartIdx对应的节点前。然后newStartIdx++。 这样遍历完后，要么newStartIdx &gt; newEndIdx，表示新的先遍历完，那就删除oldVnodes中oldStartIdx至oldEndIdx部分；要么oldStartIdx &gt; oldEndIDx，表示老的先遍历完，那就把新的还没遍历过的那段concat到oldVnodes后。 如果不是sameNode说明不值得比较，新的vnode直接代替老的vnode。 12345678const oEl = oldVnode.el // 获得老的ellet parentEle = api.parentNode(oEl) // 获得老的vnode对应DOM节点的父元素createEle(vnode) // 创建新vnode的DOM节点if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 插入DOM api.removeChild(parentEle, oldVnode.el) // 移除老的DOM元素 oldVnode = null&#125; 流程图总结 引用解析vue2.0的diff算法","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"JavaScript测试","date":"2018-10-19T14:37:49.000Z","path":"2018/10/19/JavaScript测试/","text":"JavaScript 测试使用 Jest 进行单元测试 Jest 使用正则表达式来判断哪些文件是测试文件。在默认情况下，它会执行在__tests__文件夹下的 .js 和 .jsx 文件，或者是以.test 或 .spec 结尾的文件。可以在 package.json中加入 testRegex 属性来明确。 123\"jest\": &#123; \"testRegex\": \"(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.jsx?$\"&#125; 先来用一下首先我们创建一个需要测试的模块 divide.js 12345function divide (a, b) &#123; return a / b;&#125;module.exports = divide; 接着我们创建测试文件 divide.test.js 12345const divide = require('./divide')test('dividing 6 by 3 equals 2', () =&gt; &#123; expect(divide(6, 3)).toBe(2)&#125;) 记得安装 Jest 模块npm install Jest并在package.json中加入Jest的运行脚本 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest&quot;&#125; 最后，用npm run test来运行测试，可以看到以下结果 12PASS ./divide.test.js ✓ dividing 6 by 3 equals 2 (5ms) 代码解释test函数接受三个参数，分别是： 测试名称 包含期待值的函数 测试最长等待时间 expect函数接受一个想要测试的值，并与 matcher 函数的参数比较。在本例中，想要测试的值是 divide 函数的返回值，matcher 函数是 toBe。详细的 matcher 函数可参考 Jest 的文档。 聚合测试在一个文件中可能存在多个测试。我们可以使用 describe函数来聚合它们，让代码看起来更简洁，也可以更好的定位错误 1234567891011// group-tests.test.jsdescribe('test the random function', ()=&gt; &#123; it('the type of return value should be number', () =&gt; &#123; expect(typeof Math.random()).toEqual('number') &#125;) it('the return value is between 0 and 1', () =&gt; &#123; let n = Math.random(); expect(n).toBeGreaterThanOrEqual(0) expect(n).toBeLessThan(1) &#125;)&#125;) it 是 test 的别名 假如我们将 expect(n).toBeGreaterThanOrEqual(0) 改成 expect(n).toBeGreaterThanOrEqual(0)，有概率会得到以下错误提示： 1234567FAIL ./grouping-tests.test.js ● test the random function › the return value is between 0 and 1 expect(received).toBeGreaterThanOrEqual(expected) Expected: 0.5 Received: 0.42696381528118543 使用 Enzyme 测试 React 组件首先安装 Enzyme 和 React 12npm install enzymenpm install react 接着安装 enzyme 的适配器。我们要使用 React 16.x 版本，所以安装 enzyme-adapter-react-16 1npm install enzyme-adapter-react-16 然后创建配置文件 setupTests.js 1234import &#123;configure&#125; from 'enzyme'import Adapter from 'enzyme-adapter-react-16'configure(&#123;adapter: new Adapter()&#125;); 最后在package.json中配置 123&quot;jest&quot;: &#123; &quot;setupTestFrameworkScriptFile&quot;: &quot;&lt;rootDir&gt;/enzyme/setupTests.js&quot;&#125; 浅渲染Enzyme 的 shallow 函数只渲染父组件，因此称为浅渲染。浅渲染保证被测试的组件不会受到其他组件的干扰。 首先创建一个组件 App.js 123456import React from 'react'const App = () =&gt; &#123; return &lt;div&gt;Hello, world!&lt;/div&gt;&#125;export default App; 然后创建测试文件 12345678910import React from 'react';import &#123; shallow &#125; from 'enzyme';import App from './App'describe('app component', () =&gt; &#123; it('constains a header with the \"Hello, world!\"', () =&gt; &#123; const app = shallow(&lt;App /&gt;); expect(app.containsMatchingElement(&lt;div&gt;Hello, world!&lt;/div&gt;)).toEqual(true); &#125;)&#125;) 然后我们运行测试，就可以看到以下结果： 123PASS jest/grouping-tests.test.jsPASS jest/divide.test.jsPASS enzyme/App.test.js 在这里，Jest 扮演了测试驱动器的作用。接下来看看 Enzyme 在更复杂的组件场景下的使用。 首先创建组件 TodoList.js 1234567891011121314import React from 'react';const TodoList = (props) =&gt; &#123; return ( &lt;ul&gt; &#123; props.tasks.map((task, idx) =&gt; &#123; return (&lt;li key=&#123;idx&#125;&gt;&#123;task&#125;&lt;/li&gt;); &#125;) &#125; &lt;/ul&gt; )&#125;export default TodoList; 然后创建测试文件TodoList.test.js 1234567891011import React from 'react'import &#123;shallow&#125; from 'enzyme'import TodoList from './TodoList'describe('when provide tasks props', () =&gt; &#123; it('contains same number of &lt;li&gt; Elements', () =&gt; &#123; const tasks = ['eat food', 'wash hands', 'sleep']; const todoList = shallow(&lt;TodoList tasks=&#123;tasks&#125;/&gt;); expect(todoList.find('li').length).toEqual(tasks.length) &#125;)&#125;) 运行测试后，可以看到测试全部通过。 参考 JavaScript Test Tutorial Shallow Rendering API Jest 的文档","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JWT 与 登录保持","date":"2018-07-31T05:25:35.000Z","path":"2018/07/31/JWT/","text":"1. JWT (JSON Web Token)JWT 是一种建立在 JSON 上的验证方式，目的是通过发放 token，让API资源被信任的用户访问。JWT 最大的特点是无状态，服务器创建 token 并返回给浏览器后，浏览器之后的访问都要带上这个 token，服务器并不存储 token 的信息，所以在分布式服务和大规模用户访问上更有优势。 具体可参考阮一峰老师对JWT的介绍, 下面主要谈一下登录保持。 2. 登录保持2.1 需求 用户通过帐号和密码登录，登录后在很长一段时间（e.g. 3天）内可以保持登录状态。即使用户关闭浏览器后，在若干小时后打开页面依然可以直接进入服务，而不需要重新登录。当用户隔较长时间（e.g. &gt;3天）未登录时，再次登录需要重新输入帐号和密码。 2.2 思路 使用单个 token 每次传到服务器时，判断一下过期时间。例如有效时间是3天，当检测到还剩1h token 就要失效时，就将创建一个新 token 返回给浏览器 存在的问题： 由于要实现3天内免登录，token的有效时间就要设为3天。较长的有效时间带来了较低的安全性。 剩余时间难以预测。假如设定的剩余时间是1h，用户很小概率恰好在失效前的最后一小时还在使用服务。 使用accessToken与refreshToken accessToken用来进行访问控制，它的有效时间很短，安全性更好。 refreshToken用来更新accessToken，它的有效时间很长。 当accessToken过期时，就用refreshToken重新获取accessToken。 当refreshToken也过期时，就需要重新登录。 优点：因为refreshToken存储在服务器中，所以管理人员可以删除某个refreshToken来剔除恶劣用户。 缺点：失去了无状态，服务器需要存储refreshToken。 2.3 实现 为了简化表述，存储改为在内存中存储，生产环境中请使用数据库 启动一个 nodejs 服务器，这里使用Koa框架。 123const Koa = require('koa');const app = new Koa();app.listen(3000); 初始化登录路由，获得用户名和密码后，向浏览器发放accessToken和refreshToken。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Koa = require('koa');const app = new Koa();/* 下面是增加的代码 */const bodyParser = require('koa-bodyparser');const Router = require('koa-router')const jwt = require('jsonwebtoken');const jwtKoa = require('koa-jwt');let randtoken = require('rand-token');const util = require('util');const verify = util.promisify(jwt.verify);let refreshTokens = new Map();const secret = 'jwt_demo';const router = new Router();app.use(bodyParser());app.use(jwtKoa(&#123;secret&#125;).unless(&#123; path: [/^\\/api\\/login/, /^\\/api\\/token/] /* 排除/api/login 路径 和/api/token 路径 */&#125;));router.post('/api/login', async(ctx, next) =&gt; &#123; const user = ctx.request.body; if (user &amp;&amp; user.name) &#123; let info = &#123; name: user.name &#125;; const accessToken = jwt.sign(info, secret, &#123; expiresIn: '15m'&#125;); /* 生成accessToken，有效期为15分钟 */ const refreshToken = randtoken.uid(16); /* 获取16位refreshToken */ refreshTokens.set(refreshToken, user.name); ctx.response.body = &#123; accessToken: accessToken, refreshToken: refreshToken &#125;; &#125;&#125;)app.use(router.routes()) .use(router.allowedMethods());/* 新增代码到此结束 */app.listen(3000); 初始化accessToken刷新路由。浏览器发送refreshToken，服务器验证如果map中持有该refreshToken且对应的username与发送过来的username匹配，那么就发送新的token。否则返回401错误状态。 12345678910111213141516router.post('/api/token', async (ctx, next) =&gt; &#123; const username = ctx.request.body.name; const refreshToken = ctx.request.body.refreshToken; if (refreshTokens.has(refreshToken) &amp;&amp; refreshTokens.get(refreshToken) === username) &#123; let info = &#123; name: username &#125;; let accessToken = jwt.sign(info, secret, &#123; expiresIn: '15m' &#125;); ctx.body = &#123; accessToken: accessToken &#125; &#125; else &#123; /* 401 没有权限访问，需要重新登录 */ ctx.throw(401); &#125;&#125;); 初始化一个保护的资源访问路径 12345678910111213router.get('/api/secret', async (ctx, next) =&gt; &#123; const token = ctx.header.authorization; /* 获得accessToken */ if (token) &#123; let accessToken = token.split(' ')[1]; let accessPayload = await verify(accessToken, secret); /* 解密，获取accessPayload */ ctx.body = \"It's a secret.\"; &#125; else &#123; ctx.body = &#123; message: 'token 错误', code: -1 &#125;; &#125;&#125;); 2.4 验证 用name登录，获取一个accessToken 1curl -d \"name=foo\" http://127.0.0.1:3000/api/login 返回值如下（不一定全部相同）： 1&#123;\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\",\"refreshToken\":\"SPeAsKMcbHqjBrQ5\"&#125; 不带token访问保护资源 1curl http://127.0.0.1:3000/api/secret 返回值如下： 1Authentication Error 带token访问保护资源 1curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\" http://127.0.0.1:3000/api/secret 返回值如下： 1It&apos;s a secret. 15分钟后带token访问保护资源 1curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\" http://127.0.0.1:3000/api/secret 返回值如下： 1Authentication Error 用refreshToken换accessToken 1curl -d \"name=foo&amp;refreshToken=3VqXxVFaFequGZEt\" http://127.0.0.1:3000/api/token 返回值如下： 1&#123;\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEzNzIwLCJleHAiOjE1MzMwMTQ2MjB9.5-w9P4AY033GaW77azsd6-mBMOxMMIhaqgMph_tOHpw\"&#125; refreshToken的失效可以通过数据库的updateTime来判断，如果currentTime - updateTime &gt; 3day，那么就不派发新的accessToken，并且删除旧的refreshToken记录，要求重新登录。 2.5 改进每次都要在请求头中加入token，不方便。accessToken失效，需要手动换取新的accessToken，也不方便。 因此最好有一种代理机制，能在每次发请求和收到请求时做一些处理。下面使用axios的请求拦截器来实现。 1234567cdn 引入： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;npm 引入:npm install vuenpm install axios 请求拦截，添加Authorization。 12345678axios.interceptors.request.use(config =&gt; &#123; if (localStorage.accessToken) &#123; config.headers.Authorization = 'Beared ' + localStorage.accessToken; &#125; return config;&#125;, err =&gt; &#123; return Promise.reject(err);&#125;) 响应拦截，处理token刷新 123456789101112131415161718192021222324axios.interceptors.response.use(async res =&gt; &#123; /* 处理token过期 */ /* 如果code === -1，表示token无效，需要刷新 */ if (res.data.code === -1) &#123; await axios.post('/api/token', &#123; name: localStorage.username ? localStorage.username : '', refreshToken: localStorage.refreshToken ? localStorage.refreshToken : '' &#125;).then(async res2 =&gt; &#123; /* 将返回的新token存起来 */ localStorage.setItem('accessToken', res2.data.accessToken); /* 再次发送之前因为token过期而失败的请求 */ let &#123; method, url, data &#125; = res.config; await axios[method](url, data).then((res3)=&gt; &#123; res = res3; /* 将失败的请求响应换成成功的请求响应 */ &#125;) &#125;).catch((err) =&gt; &#123; this.authenticated = false; /* 如果refreshToken也失败，那就要重新登录 */ &#125;) &#125; return res;&#125;, function (error) &#123;return Promise.reject(error);&#125;); Vue 文件 1234567891011121314151617181920212223242526272829data()&#123; return &#123; username: '', password: '', authenticated: true, secret: '' &#125;&#125;,methods: &#123; login() &#123; const &#123; username, password &#125; = this; axios.post('/api/login', &#123; name: username &#125;).then(res =&gt; &#123; localStorage.setItem('username', this.username); localStorage.setItem('accessToken', res.data.accessToken); localStorage.setItem('refreshToken', res.data.refreshToken); this.authenticated = true; this.getSecret(); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;) &#125;, getSecret() &#123; axios.get('/api/secret').then(res =&gt; &#123; this.secret = res.data &#125;) &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"2017","date":"2017-12-27T08:05:09.000Z","path":"2017/12/27/2017/","text":"January穷游杭州 很幸运订到一家很漂亮的民宿，刷新了我对青年旅舍的理解 一起吃兰州拉面，玩桌游 三小时徒步西湖，雷锋塔顶看日落夕阳 深夜12点还在杭州的路上瞎逛，“和我在杭州的街头走一走，哦~~，直到所有的灯都熄灭了也不停留” Blog 1.0March 鸡鸣寺看樱花，一个人逛玄武湖，带上耳机净化心灵 May iPhone 5 -&gt; iPhone 7 终于换手机啦，原来的iPhone 5屏幕实在是太小了，而且容量也不够大，换了 7 之后，异常流畅，不够据说Cook又给7的CPU降频了，打死也不更新系统了（更新了ios 11，有一次突然要我同意一份协议，然后莫名其妙升级了） Sister Married emmmmmm不能常见面了呢 最美好时光就是除夕夜一起放烟花了吧，今年放烟花恐怕只有我一人了 爸爸把姐姐搀上台的一刻感动哭了 June Manchester by the Sea 年度电影，一部很丧的电影，看完却很治愈 一个沉默的灵魂背后，永远不知道他背负了怎样的生死离别 July Driver‘s license 科目三考试遇上台风天气，我的车技是受过考验的 第一次4：30起床 August Teaching in Anhui 在霍邱支教，又体验了一下农村的生活，仿佛一下子回到2003年我刚上小学那会儿 十多天，每天六点起，十一点睡，吃相同的饭，做不同的事，能坚持下来，要谢谢一起支教的同学 September New semester 选了很多课，想做很多事，背负了更多的责任，可时间有限，觉得很累 October Mountain climbing 一起爬了东盘山 第二次4：30起床 山底下的生煎和紫菜汤真的很好吃！！ 富游南京 南京人生无限公司 其实我就是个地陪 坐在老门东的台阶上，一起“换脸” 来了南京之后，一直没去的夫子庙，商业气息很重，晚上的灯光景色也非常的商业化 在酒店里吃火锅，做饭（主要是煎蛋啦），玩大富翁玩到凌晨3点（我真的怕自己猝死） 最好的朋友就是可以一起大哭一起大笑吧，和你们在一起是我最放松最自我的状态 November Blog 2.0 在学习Vue 2.0 ，觉得教程的网页样式很好看，想做成博客，没想到真的有和我一样想法的人 When the wind blows 年度音乐，治愈系的声音 The Year 有的时候为别人考虑太多，反而伤害了自己 有的时候太犹豫不决，唯唯诺诺，错过了很多机会 有的时候想做，却没有几分钟热度 有的时候想做，又不敢做 注重体验生活的一年，去支教是我意料之外的事情 2018 攒钱买一台MacBook Pro 不想让爸妈出钱，我也是有房贷在身的人了 MBP的系统和屏幕 原来的电脑硬盘太小了 做一个自己的前端项目 一直没有去实现一个自己的idea ✈成都&amp;重庆 一个赛博风格的城市 更加敢想敢做，Be yourself","tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"Sakura","date":"2017-03-25T11:00:09.000Z","path":"2017/03/25/sakura/","text":"今天去看了樱花，一个人走在樱花路上，看见家长们带着调皮的孩子，看见一长串身着绿色校服的中学生来春游，互相笑着，调侃着，追赶奔跑着，仿佛曾经的自己 最近消化道不太舒服，有时候想多睡一会儿，就少了吃饭的时间，满足了第一个大脑，第二个“大脑”也会抗议的吧。对于远离父母的大学生来说，得病应该是最忌讳的事情了，没有父母的照料，饮食上无法选择，就像是刚出生的婴儿一样，毫无招架之力","tags":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/tags/随想/"}]},{"title":"Hello Blog!","date":"2017-03-01T10:50:17.000Z","path":"2017/03/01/关于此博客/","text":"1.博客的诞生几天前在知乎上看见了一篇搭建博客的文章,寒假里也有搭建博客的想法，但是因为服务器和域名的门槛太高就搁置了，但是这篇文章中 hexo + github 的方法还是很简单的。 最重要的是可以自己设置界面，不像网易博客或者微博，有很大的自主权限。 2.项目中的技术github的使用，git版本控制和shell命令行模式的使用，HTML + CSS + JavaScript，SSH key，hexo框架，markdown。 2017.3.4 更新 markdown语法熟悉，老师要求需求等一系列文档用md格式 推荐编辑软件Typora 3.从项目中的收获因为有教程，一步一步来不会出太大差错。主要踩坑的地方就是_config.yml文件的配置。 1.图床。博客的头像以及文章中的图片都需要放置在云上，通过url获取，因为github空间有限制。 2.社交媒体的导航。也采用url的形式，例如weibo.com/username 3.打赏功能。收款的二维码图片在支付宝二维码平台获取 4.网站icon。favicon是网站的图标，应该放在source文件夹中。icon的大小为16 16或32 32。后缀名可以是ico或png，可以通过在线icon制作网站，如bitbug来转换。 5.github的使用。fork 别人的项目。 repository 代码仓库。pull request 提交代码请求","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]
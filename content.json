{"pages":[{"title":"About","text":"我是 lioder，一个专业的 Programmer 和业余的 Designer目前就读于南京大学软件学院，擅长前端开发目前沉迷于 胶片摄影 | VLOG典型的天秤座，经常出现 选择困难 | 社交障碍 悲观主义者 | 生活爱好者由于微信和 QQ 有许多沉积的关系链，所以目前只用来即时沟通，大部分时间活跃在 微博","link":"/about/index.html"},{"title":"Project","text":"233","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"对生活与爱好的思考","text":"最近一直觉得写代码不能成为我生活的唯一，但是这不能成为我每天看无聊视频和打游戏的借口。参加黑客马拉松是我选择接受新生活的一个起点。我还是应该多读点书，做点有意思的事。 大概有这么几件事还比较感兴趣： 我希望我的饭后娱乐方式不只有窝在宿舍打王者荣耀和看视频这两种方式。 一是学习说脱口秀，从高一开始就在看《今晚80后脱口秀》，看到17年节目停播，后来接着看《吐槽大会》《脱口秀大会》《冒犯家族》《周六夜现场》，有时候也会看《噗嗤脱口秀》和线下开放麦，我真的挺喜欢这种语言文字小幽默的，所以最近打算看一下《手把手教你玩脱口秀》。 二是学习手绘与设计，从大一开始就有关注设计，在退出宣传部工作之后，我就很少碰设计了。最近看到设计青年的微博上有很有意思的互动。就是博主发一张素材图片(一个很简单的物件或是其他意象)，其他人可以在此基础上继续绘制，展现创意。评论区的作品我看了还是非常震撼的，所以打算学一下，当然这玩意儿还需要apple pen和一台iPad，所以可能优先级不是特别高。 三是学习乐理和编曲，非常爱听电子乐，尤其是Trap和Future Bass，但是我对基本的乐理知识一窍不通，乐器也只会竖笛，所以想要学习一下基本的乐理知识，尝试用软件进行编曲，有机会的话买一把尤克里里学习一下乐器的演奏。 四是拍摄VLOG，我的生活非常无聊，之前几个月尝试拍了一下，但是素材很少，最近有点放弃了，因此错过了许多很好的素材(比如黑客马拉松)，希望之后能keep下去，VLOG对我来说就像是一个强迫自己走出去的方式。 最后，我又换了Blog主题，卡片式设计是我一直非常热衷的，希望能督促我多写一些文章，下篇文章再见，如果还有下一篇的话。","link":"/2019/06/03/2019-06-02/"},{"title":"2017","text":"January穷游杭州 很幸运订到一家很漂亮的民宿，刷新了我对青年旅舍的理解 一起吃兰州拉面，玩桌游 三小时徒步西湖，雷锋塔顶看日落夕阳 深夜12点还在杭州的路上瞎逛，“和我在杭州的街头走一走，哦~~，直到所有的灯都熄灭了也不停留” Blog 1.0 March 鸡鸣寺看樱花，一个人逛玄武湖，带上耳机净化心灵 May iPhone 5 -&gt; iPhone 7 终于换手机啦，原来的iPhone 5屏幕实在是太小了，而且容量也不够大，换了 7 之后，异常流畅，不够据说Cook又给7的CPU降频了，打死也不更新系统了（更新了ios 11，有一次突然要我同意一份协议，然后莫名其妙升级了） Sister Married emmmmmm不能常见面了呢 最美好时光就是除夕夜一起放烟花了吧，今年放烟花恐怕只有我一人了 爸爸把姐姐搀上台的一刻感动哭了 June Manchester by the Sea 年度电影，一部很丧的电影，看完却很治愈 一个沉默的灵魂背后，永远不知道他背负了怎样的生死离别 July Driver‘s license 科目三考试遇上台风天气，我的车技是受过考验的 第一次4：30起床 August Teaching in Anhui 在霍邱支教，又体验了一下农村的生活，仿佛一下子回到2003年我刚上小学那会儿 十多天，每天六点起，十一点睡，吃相同的饭，做不同的事，能坚持下来，要谢谢一起支教的同学 September New semester 选了很多课，想做很多事，背负了更多的责任，可时间有限，觉得很累 October Mountain climbing 一起爬了东盘山 第二次4：30起床 山底下的生煎和紫菜汤真的很好吃！！ 富游南京 南京人生无限公司 其实我就是个地陪 坐在老门东的台阶上，一起“换脸” 来了南京之后，一直没去的夫子庙，商业气息很重，晚上的灯光景色也非常的商业化 在酒店里吃火锅，做饭（主要是煎蛋啦），玩大富翁玩到凌晨3点（我真的怕自己猝死） 最好的朋友就是可以一起大哭一起大笑吧，和你们在一起是我最放松最自我的状态 November Blog 2.0 在学习Vue 2.0 ，觉得教程的网页样式很好看，想做成博客，没想到真的有和我一样想法的人 When the wind blows 年度音乐，治愈系的声音 The Year 有的时候为别人考虑太多，反而伤害了自己 有的时候太犹豫不决，唯唯诺诺，错过了很多机会 有的时候想做，却没有几分钟热度 有的时候想做，又不敢做 注重体验生活的一年，去支教是我意料之外的事情 2018 攒钱买一台MacBook Pro 不想让爸妈出钱，我也是有房贷在身的人了 MBP的系统和屏幕 原来的电脑硬盘太小了 做一个自己的前端项目 一直没有去实现一个自己的idea ✈成都&amp;重庆 一个赛博风格的城市 更加敢想敢做，Be yourself","link":"/2017/12/27/2017/"},{"title":"Hackthon 全记录","text":"2019 年 5 月 26 日 ~ 2019 年 5 月 27日在仙林校区参加了一场黑客马拉松。在此记录一下这段经历。 26日上午早上6:45从睡梦中苏醒，外面下着瓢泼大雨，这大概是入夏以来第一场大雨，我很喜欢下雨天，雨滴声让我觉得宁静。 大概收拾了一下，就和小伙伴一起乘地铁前往仙林，到了学校后，轻车熟路进了基础实验楼，来到机房，办理了身份认证手续后就开始准备了。 早上9:00，题目发布，和小伙伴们花了20分钟讨论了一下作品的主题，很快达成一致，我们选择做一个作业发布批改的平台。但是我其实拒绝将这个平台复杂化，例如加入班级等增加复杂度的需求，可惜队员们一致认为需要保留，遂作罢。 9:00~12:00，写好了登录注册的页面，可是后端由于数据库和jenkins等问题，一直没有把项目部署上，同时由于我之前没有用过NGINX，导致在前端部署上花了很多时间，最后选择了NodeJS和express做了一个静态文件的服务器，勉强解决前端部署。但是jenkins依旧失败，由于时间紧迫，遂作罢。 26日下午12:00~18:00，我们写好了班级管理的一系列页面，并且完成了前后端的集成测试，项目能够稳定运行。 我们依旧没有进入作业这一核心模块，从最后答辩展示来看，班级管理并没有展示，也就是说这6个小时几乎是做了无用功。 但是这六个小时，是差不多整个赛程精神状态最好的时候。 18:00时，我颈椎已经开始难受，并开始对我今后的职业生涯开始担忧。 26日晚上18:00~19:00，在酒店吃了一餐自助，菜品种类和味道尚可，但是写了一天代码也没啥胃口(特别是知道晚上要继续写，也没啥心情品尝)。 19:00~24:00，基本完成了作业发布和答题的功能，这一个阶段效率不是特别高，已经有些疲劳，而且后端由于ORM关系映射问题，导致项目开发进度缓慢，此处还要吐槽一下elementUI的upload组件，用了好几次都不是特别好用。 期间花了20分钟，回酒店洗了个澡。南大校内竟有如此豪华的酒店，令我十分震惊。 24:00~2:00，开始开发批改模块，并对批改模块的数据交互方式产生分歧，最终选取类feed流模式，从未批改的题库中feed题给教师批改。 2:00~7:45，实在是写不动了，准备睡觉。我们将两张床拼在了一起(辛苦第二天的保洁阿姨了)，从柜子中找出了一床备用被子，三个人倒头就睡了。 27号上午8:00~12:00，完成了作业批改模块的开发，并且和评委进行了简单的交流。顺便清除了一些BUG。 中午依旧是自助餐，较26号晚上菜品种类和质量有所提升。 27号下午12:00~15:00，完成了作业报告模块的开发，限于时间紧迫，只开发了教师模块。 15:00~18:00，在计科楼报告厅答辩，有许多组做的都非常有意思。 18:00左右，我们组答辩，系统在演示时出现了小问题(墨菲定律，你最担心的事情总会发生)，队长的答辩回答也比较套话，当然我十分佩服他能上去作演讲，至少我不是那么勇敢。 最后我们成绩不是很好，也没有获得奖项。 期间还去五食堂吃了鸡汁米线，我在仙林的时候非常喜欢吃这道菜，但是搬到鼓楼就没了。 收获在参加过程中，还有参加结束后，我都有一些感想，这里只谈我自己。 一是对于技术，对于jenkins还有NGINX这些发布部署方面的知识比较欠缺，因此耗费了大量的时间。 二是对于体力，在比赛的整个过程中体力不是很好，最后腰酸背痛颈椎疼，希望本科结束之后可以将健身提上日程。 三是对于比赛，黑客马拉松其实最后评委喜欢以及你展示的是项目的亮点，所以一些细枝末节的功能可以省略。我们就是花了太多时间在班级这一块，导致报告这个aim没有很好的实现，项目就没有了亮点。 四是对于沟通，我希望我有时候不要那么容易妥协，对于自己要有自信，能坚持自己的观点并说服别人（由班级管理想到）。我也希望自己有时候能较较真，不要因为一些时间原因，就选择了效率更低的方案（由放弃NGINX部署想到）。我也希望对于我重视的事情我能积极的去掌握主动权，而不是交给别人去掌握命运（由答辩想到）。 最后，下篇文章见，如果还有下一篇的话。","link":"/2019/06/02/hackthon/"},{"title":"JWT 与 登录保持","text":"1. JWT (JSON Web Token)JWT 是一种建立在 JSON 上的验证方式，目的是通过发放 token，让API资源被信任的用户访问。JWT 最大的特点是无状态，服务器创建 token 并返回给浏览器后，浏览器之后的访问都要带上这个 token，服务器并不存储 token 的信息，所以在分布式服务和大规模用户访问上更有优势。 具体可参考阮一峰老师对JWT的介绍, 下面主要谈一下登录保持。 2. 登录保持2.1 需求 用户通过帐号和密码登录，登录后在很长一段时间（e.g. 3天）内可以保持登录状态。即使用户关闭浏览器后，在若干小时后打开页面依然可以直接进入服务，而不需要重新登录。当用户隔较长时间（e.g. &gt;3天）未登录时，再次登录需要重新输入帐号和密码。 2.2 思路 使用单个 token 每次传到服务器时，判断一下过期时间。例如有效时间是3天，当检测到还剩1h token 就要失效时，就将创建一个新 token 返回给浏览器 存在的问题： 由于要实现3天内免登录，token的有效时间就要设为3天。较长的有效时间带来了较低的安全性。 剩余时间难以预测。假如设定的剩余时间是1h，用户很小概率恰好在失效前的最后一小时还在使用服务。 使用accessToken与refreshToken accessToken用来进行访问控制，它的有效时间很短，安全性更好。 refreshToken用来更新accessToken，它的有效时间很长。 当accessToken过期时，就用refreshToken重新获取accessToken。 当refreshToken也过期时，就需要重新登录。 优点：因为refreshToken存储在服务器中，所以管理人员可以删除某个refreshToken来剔除恶劣用户。 缺点：失去了无状态，服务器需要存储refreshToken。 2.3 实现 为了简化表述，存储改为在内存中存储，生产环境中请使用数据库 启动一个 nodejs 服务器，这里使用Koa框架。 123const Koa = require('koa');const app = new Koa();app.listen(3000); 初始化登录路由，获得用户名和密码后，向浏览器发放accessToken和refreshToken。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Koa = require('koa');const app = new Koa();/* 下面是增加的代码 */const bodyParser = require('koa-bodyparser');const Router = require('koa-router')const jwt = require('jsonwebtoken');const jwtKoa = require('koa-jwt');let randtoken = require('rand-token');const util = require('util');const verify = util.promisify(jwt.verify);let refreshTokens = new Map();const secret = 'jwt_demo';const router = new Router();app.use(bodyParser());app.use(jwtKoa({secret}).unless({ path: [/^\\/api\\/login/, /^\\/api\\/token/] /* 排除/api/login 路径 和/api/token 路径 */}));router.post('/api/login', async(ctx, next) =&gt; { const user = ctx.request.body; if (user &amp;&amp; user.name) { let info = { name: user.name }; const accessToken = jwt.sign(info, secret, { expiresIn: '15m'}); /* 生成accessToken，有效期为15分钟 */ const refreshToken = randtoken.uid(16); /* 获取16位refreshToken */ refreshTokens.set(refreshToken, user.name); ctx.response.body = { accessToken: accessToken, refreshToken: refreshToken }; }})app.use(router.routes()) .use(router.allowedMethods());/* 新增代码到此结束 */app.listen(3000); 初始化accessToken刷新路由。浏览器发送refreshToken，服务器验证如果map中持有该refreshToken且对应的username与发送过来的username匹配，那么就发送新的token。否则返回401错误状态。 12345678910111213141516router.post('/api/token', async (ctx, next) =&gt; { const username = ctx.request.body.name; const refreshToken = ctx.request.body.refreshToken; if (refreshTokens.has(refreshToken) &amp;&amp; refreshTokens.get(refreshToken) === username) { let info = { name: username }; let accessToken = jwt.sign(info, secret, { expiresIn: '15m' }); ctx.body = { accessToken: accessToken } } else { /* 401 没有权限访问，需要重新登录 */ ctx.throw(401); }}); 初始化一个保护的资源访问路径 12345678910111213router.get('/api/secret', async (ctx, next) =&gt; { const token = ctx.header.authorization; /* 获得accessToken */ if (token) { let accessToken = token.split(' ')[1]; let accessPayload = await verify(accessToken, secret); /* 解密，获取accessPayload */ ctx.body = \"It's a secret.\"; } else { ctx.body = { message: 'token 错误', code: -1 }; }}); 2.4 验证 用name登录，获取一个accessToken 1curl -d \"name=foo\" http://127.0.0.1:3000/api/login 返回值如下（不一定全部相同）： 1{\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\",\"refreshToken\":\"SPeAsKMcbHqjBrQ5\"} 不带token访问保护资源 1curl http://127.0.0.1:3000/api/secret 返回值如下： 1Authentication Error 带token访问保护资源 1curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\" http://127.0.0.1:3000/api/secret 返回值如下： 1It&apos;s a secret. 15分钟后带token访问保护资源 1curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEyNTg0LCJleHAiOjE1MzMwMTI2NDR9.ch_APWPnCmZru_8uKNxAH4I68lLf46oVNU3rqdGs8LE\" http://127.0.0.1:3000/api/secret 返回值如下： 1Authentication Error 用refreshToken换accessToken 1curl -d \"name=foo&amp;refreshToken=3VqXxVFaFequGZEt\" http://127.0.0.1:3000/api/token 返回值如下： 1{\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZm9vIiwiaWF0IjoxNTMzMDEzNzIwLCJleHAiOjE1MzMwMTQ2MjB9.5-w9P4AY033GaW77azsd6-mBMOxMMIhaqgMph_tOHpw\"} refreshToken的失效可以通过数据库的updateTime来判断，如果currentTime - updateTime &gt; 3day，那么就不派发新的accessToken，并且删除旧的refreshToken记录，要求重新登录。 2.5 改进每次都要在请求头中加入token，不方便。accessToken失效，需要手动换取新的accessToken，也不方便。 因此最好有一种代理机制，能在每次发请求和收到请求时做一些处理。下面使用axios的请求拦截器来实现。 1234567cdn 引入： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;npm 引入:npm install vuenpm install axios 请求拦截，添加Authorization。 12345678axios.interceptors.request.use(config =&gt; { if (localStorage.accessToken) { config.headers.Authorization = 'Beared ' + localStorage.accessToken; } return config;}, err =&gt; { return Promise.reject(err);}) 响应拦截，处理token刷新 123456789101112131415161718192021222324axios.interceptors.response.use(async res =&gt; { /* 处理token过期 */ /* 如果code === -1，表示token无效，需要刷新 */ if (res.data.code === -1) { await axios.post('/api/token', { name: localStorage.username ? localStorage.username : '', refreshToken: localStorage.refreshToken ? localStorage.refreshToken : '' }).then(async res2 =&gt; { /* 将返回的新token存起来 */ localStorage.setItem('accessToken', res2.data.accessToken); /* 再次发送之前因为token过期而失败的请求 */ let { method, url, data } = res.config; await axios[method](url, data).then((res3)=&gt; { res = res3; /* 将失败的请求响应换成成功的请求响应 */ }) }).catch((err) =&gt; { this.authenticated = false; /* 如果refreshToken也失败，那就要重新登录 */ }) } return res;}, function (error) {return Promise.reject(error);}); Vue 文件 1234567891011121314151617181920212223242526272829data(){ return { username: '', password: '', authenticated: true, secret: '' }},methods: { login() { const { username, password } = this; axios.post('/api/login', { name: username }).then(res =&gt; { localStorage.setItem('username', this.username); localStorage.setItem('accessToken', res.data.accessToken); localStorage.setItem('refreshToken', res.data.refreshToken); this.authenticated = true; this.getSecret(); }).catch((err) =&gt; { console.log(err); }) }, getSecret() { axios.get('/api/secret').then(res =&gt; { this.secret = res.data }) }}","link":"/2018/07/31/JWT/"},{"title":"JavaScript测试","text":"使用 Jest 进行单元测试 Jest 使用正则表达式来判断哪些文件是测试文件。在默认情况下，它会执行在__tests__文件夹下的 .js 和 .jsx 文件，或者是以.test 或 .spec 结尾的文件。可以在 package.json中加入 testRegex 属性来明确。 123\"jest\": { \"testRegex\": \"(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.jsx?$\"} 先来用一下首先我们创建一个需要测试的模块 divide.js 12345function divide (a, b) { return a / b;}module.exports = divide; 接着我们创建测试文件 divide.test.js 12345const divide = require('./divide')test('dividing 6 by 3 equals 2', () =&gt; { expect(divide(6, 3)).toBe(2)}) 记得安装 Jest 模块npm install Jest并在package.json中加入Jest的运行脚本 123&quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;} 最后，用npm run test来运行测试，可以看到以下结果 12PASS ./divide.test.js ✓ dividing 6 by 3 equals 2 (5ms) 代码解释test函数接受三个参数，分别是： 测试名称 包含期待值的函数 测试最长等待时间 expect函数接受一个想要测试的值，并与 matcher 函数的参数比较。在本例中，想要测试的值是 divide 函数的返回值，matcher 函数是 toBe。详细的 matcher 函数可参考 Jest 的文档。 聚合测试在一个文件中可能存在多个测试。我们可以使用 describe函数来聚合它们，让代码看起来更简洁，也可以更好的定位错误 1234567891011// group-tests.test.jsdescribe('test the random function', ()=&gt; { it('the type of return value should be number', () =&gt; { expect(typeof Math.random()).toEqual('number') }) it('the return value is between 0 and 1', () =&gt; { let n = Math.random(); expect(n).toBeGreaterThanOrEqual(0) expect(n).toBeLessThan(1) })}) it 是 test 的别名 假如我们将 expect(n).toBeGreaterThanOrEqual(0) 改成 expect(n).toBeGreaterThanOrEqual(0)，有概率会得到以下错误提示： 1234567FAIL ./grouping-tests.test.js ● test the random function › the return value is between 0 and 1 expect(received).toBeGreaterThanOrEqual(expected) Expected: 0.5 Received: 0.42696381528118543 使用 Enzyme 测试 React 组件首先安装 Enzyme 和 React 12npm install enzymenpm install react 接着安装 enzyme 的适配器。我们要使用 React 16.x 版本，所以安装 enzyme-adapter-react-16 1npm install enzyme-adapter-react-16 然后创建配置文件 setupTests.js 1234import {configure} from 'enzyme'import Adapter from 'enzyme-adapter-react-16'configure({adapter: new Adapter()}); 最后在package.json中配置 123&quot;jest&quot;: { &quot;setupTestFrameworkScriptFile&quot;: &quot;&lt;rootDir&gt;/enzyme/setupTests.js&quot;} 浅渲染Enzyme 的 shallow 函数只渲染父组件，因此称为浅渲染。浅渲染保证被测试的组件不会受到其他组件的干扰。 首先创建一个组件 App.js 123456import React from 'react'const App = () =&gt; { return &lt;div&gt;Hello, world!&lt;/div&gt;}export default App; 然后创建测试文件 12345678910import React from 'react';import { shallow } from 'enzyme';import App from './App'describe('app component', () =&gt; { it('constains a header with the \"Hello, world!\"', () =&gt; { const app = shallow(&lt;App /&gt;); expect(app.containsMatchingElement(&lt;div&gt;Hello, world!&lt;/div&gt;)).toEqual(true); })}) 然后我们运行测试，就可以看到以下结果： 123PASS jest/grouping-tests.test.jsPASS jest/divide.test.jsPASS enzyme/App.test.js 在这里，Jest 扮演了测试驱动器的作用。接下来看看 Enzyme 在更复杂的组件场景下的使用。 首先创建组件 TodoList.js 1234567891011121314import React from 'react';const TodoList = (props) =&gt; { return ( &lt;ul&gt; { props.tasks.map((task, idx) =&gt; { return (&lt;li key={idx}&gt;{task}&lt;/li&gt;); }) } &lt;/ul&gt; )}export default TodoList; 然后创建测试文件TodoList.test.js 1234567891011import React from 'react'import {shallow} from 'enzyme'import TodoList from './TodoList'describe('when provide tasks props', () =&gt; { it('contains same number of &lt;li&gt; Elements', () =&gt; { const tasks = ['eat food', 'wash hands', 'sleep']; const todoList = shallow(&lt;TodoList tasks={tasks}/&gt;); expect(todoList.find('li').length).toEqual(tasks.length) })}) 运行测试后，可以看到测试全部通过。 参考 JavaScript Test Tutorial Shallow Rendering API Jest 的文档","link":"/2018/10/19/JavaScript测试/"},{"title":"Sakura","text":"今天去看了樱花，一个人走在樱花路上，看见家长们带着调皮的孩子，看见一长串身着绿色校服的中学生来春游，互相笑着，调侃着，追赶奔跑着，仿佛曾经的自己 最近消化道不太舒服，有时候想多睡一会儿，就少了吃饭的时间，满足了第一个大脑，第二个“大脑”也会抗议的吧。对于远离父母的大学生来说，得病应该是最忌讳的事情了，没有父母的照料，饮食上无法选择，就像是刚出生的婴儿一样，毫无招架之力","link":"/2017/03/25/sakura/"},{"title":"微服务从0开始","text":"写在前面因为第二学期软件设计与体系结构课上一直在强调微服务，最后也设计了一个微服务的体系结构，但自己对微服务其实还是一知半解（别笑）。秉持的实践出真知的原则，我还是打算写一个微服务来全面理解一下。 下面列举了我在没有实践微服务之前主要的疑惑： RPC是什么，为什么服务之间不使用Rest和HTTP通信？ 服务注册和服务发现是什么？ 为什么要用NGINX？ Docker在微服务中有什么用？ CI和CD在微服务中怎样实践？ 服务编排是什么？k8s的作用是什么？ 正题 我学习微服务主要是用Go语言 问题1 RPC是什么，为什么服务之间不使用Rest和HTTP通信？ 如果使用Rest和HTTP，那么服务间传递数据是这样的： 服务A将数据encode成json字符串，通过ajax发送给服务B，服务B parse成对象 如果使用gRPC，那么服务间传递数据是这样的： 使用protobuf协议约定数据格式，服务A将数据转化为二进制数据流，基于HTTP 2.0 的二进制数据帧发送给服务B，服务B按照约定的格式parse成对象 微服务可以使用Rest和HTTP通信，但是多了encode和decode的步骤 最基本的微服务结构 先使用protobuf语法定义一个微服务以及他的方法，定义一系列消息对象 然后通过protobuf编译器编译成go语言文件，文件中包含了定义的消息结构体，一系列微服务方法以及接口 写一个service，实现上述接口 创建一个gRPC服务器，将我们的service与协议中的微服务绑定 写一个client，首先拨号连接到gRPC服务器，然后调用协议中的方法创建客户端，客户端可以调用协议中定义的微服务的各种方法 从客户端出发来看，客户端先获取gRPC服务器的连接，然后通过.pb.go获得服务的调用器，之后就像调用本地方法一样使用 而service这边，创建了一个gRPC服务器，并将自己进行注册 问题2 服务注册和服务发现是什么？ 服务注册已经出现了，service会将自己注册到gRPC服务器中，也就是将自己的ip地址和端口告诉gRPC服务器，这是一种主动的注册。 在客户端这边，我们写死了ip地址和端口，这会导致服务重新部署后，如果ip地址或端口改变，那么所有依赖该服务的客户端中写死的ip地址和端口都要手动更新，这是一件非常繁琐的事情。 所以我们需要服务发现机制。注册中心主动的去探测服务，当服务上线时注册，下线时注销，其他服务可以通过名字或ID找到该服务。 我们使用go-micro框架来实现服务发现。在注册时只提供自己的服务名称，端口配置从代码中分开，写在Makefile中。客户端通过服务名称来寻找服务，可以与DNS进行类比，服务上线时会组播自己的IP和服务名，记录在mDNS服务中，当你遇到陌生服务时，可以向其他mDNS服务询问。 参考这里只做一个梳理和记录，具体的实践代码可以参考：Golang 微服务教程（一）","link":"/2019/05/07/microservice1/"},{"title":"Vue-diff-算法","text":"Vue diff 算法在Vue中用virtual DOM来对应真实的DOM，每一个DOM节点用一个vnode表示。那么当数据更新时，如何知道哪些vnode需要更新呢？答案就是使用diff算法。 diff算法只按层级比较。 从什么时候开始patch？当数据通过set修改时，会调用闭包中的Dep，Dep通知所有注册的watcher进行更新。 更新方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this /*如果已经该组件已经挂载过了则代表进入这个步骤是个更新的过程，触发beforeUpdate钩子*/ if (vm._isMounted) { callHook(vm, 'beforeUpdate') } const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. /*基于后端渲染Vue.prototype.__patch__被用来作为一个入口*/ if (!prevVnode) { // initial render vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } activeInstance = prevActiveInstance // update __vue__ reference /*更新新的实例对象的__vue__*/ if (prevEl) { prevEl.__vue__ = null } if (vm.$el) { vm.$el.__vue__ = vm } // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el } // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. } 方法第一个参数传入新的vnode，将旧的vnode赋值给preVnode，然后将新的vnode赋值给当前组件的vnode，然后执行vm.__patch__(prevVnode, vnode)。 怎么 patch？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*createPatchFunction的返回值，一个patch函数*/ return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) { /*旧vode存在，新vnode不存在，就调用销毁的钩子函数*/ if (isUndef(vnode)) { if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) { // empty mount (likely as component), create new root element /*oldVnode未定义的时候，其实也就是root节点，创建一个新的节点*/ isInitialPatch = true createElm(vnode, insertedVnodeQueue, parentElm, refElm) } else { /*标记旧的VNode是否有nodeType*/ /*Github:https://github.com/answershuto*/ const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // patch existing root node /*是同一个节点的时候直接修改现有的节点*/ patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) } else { if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { /*当旧的VNode是服务端渲染的元素，hydrating记为true*/ oldVnode.removeAttribute(SSR_ATTR) hydrating = true } if (isTrue(hydrating)) { /*需要合并到真实DOM上*/ if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { /*调用insert钩子*/ invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } else if (process.env.NODE_ENV !== 'production') { warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' + 'full client-side render.' ) } } // either not server-rendered, or hydration failed. // create an empty node and replace it /*如果不是服务端渲染或者合并到真实DOM失败，则创建一个空的VNode节点替换它*/ oldVnode = emptyNodeAt(oldVnode) } // replacing existing element /*取代现有元素*/ const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) if (isDef(vnode.parent)) { // component root element replaced. // update parent placeholder node element, recursively /*组件根节点被替换，遍历更新父节点element*/ let ancestor = vnode.parent while (ancestor) { ancestor.elm = vnode.elm ancestor = ancestor.parent } if (isPatchable(vnode)) { /*调用create回调*/ for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, vnode.parent) } } } if (isDef(parentElm)) { /*移除老节点*/ removeVnodes(parentElm, [oldVnode], 0, 0) } else if (isDef(oldVnode.tag)) { /*Github:https://github.com/answershuto*/ /*调用destroy钩子*/ invokeDestroyHook(oldVnode) } } }js /*调用insert钩子*/ invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm } 分为两种情况： sameNode和非sameNode 如何判断sameNode?两节点key相同，tag相同，同为注释节点或同不为注释节点，是否定义data，是否有相同的类型（当tag为input时） 1234567891011121314151617function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) )}function sameInputType (a, b) { if (a.tag !== 'input') return true let i const typeA = isDef(i = a.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type const typeB = isDef(i = b.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type return typeA === typeB} patchVnode如果是sameVnode，就执行patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)。 12345678910111213141516171819202122232425262728const elm = vnode.elm = oldVnode.elm const oldCh = oldVnode.children const ch = vnode.children /*如果这个VNode节点没有text文本时*/ if (isUndef(vnode.text)) { if (isDef(oldCh) &amp;&amp; isDef(ch)) { /*新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren*/ if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) } else if (isDef(ch)) { /*如果老节点没有子节点而新节点存在子节点，先清空elm的文本内容，然后为当前节点加入子节点*/ if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) } else if (isDef(oldCh)) { /*当新节点没有子节点而老节点有子节点的时候，则移除所有ele的子节点*/ removeVnodes(elm, oldCh, 0, oldCh.length - 1) } else if (isDef(oldVnode.text)) { /*当新老节点都无子节点的时候，只是文本的替换，因为这个逻辑中新节点text不存在，所以直接去除ele的文本*/ nodeOps.setTextContent(elm, '') } } else if (oldVnode.text !== vnode.text) { /*当新老节点text不一样时，直接替换这段文本*/ nodeOps.setTextContent(elm, vnode.text) } /*调用postpatch钩子*/ if (isDef(data)) { if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) } 首先newVnode如果是文本节点，就直接将老的文本节点内容，换成新的文本节点内容。 如果不是，则要比较他们的children。 那么有四种情况： 新的有，老的也有 新的有，老的没有 新的没有，老的有 新的没有，老的也没有 先看最简单的，第四种。因为在这里newVnode不是文本节点，它又没有children，说明他是个空节点，那就删除旧节点的内容。 然后看第三种。新的没有，老的有，那就把老的节点内容都删了。 删除的调用是：removeVnodes(elm, oldCh, 0, oldCh.length - 1) removeVnodes是一个批量删除节点的方法，参数含义分别是父元素，vnodes列表，开始索引和结束索引，其实有用的是后三个。调用时会把从0~oldCh.length-1的vnode取出来，然后通过vnode.elm获得真实的DOM元素，然后通过nodeOps（一层DOM操作API封装）去删除真实的节点。 然后再看第二种。新的有，老的没有。那就把老的节点内容清空，然后加入新的节点内容。 增加的调用是：addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) addVnodes是一个批量增加节点的方法，参数含义分别是，父元素，ref元素（不为null的话表示指定插在它前面），插入的vnodes列表，开始索引，结束索引。 addVnodes内部会调用createElm创建真实dom节点，然后append在父元素下 最后是第一种，新的有老的也有。那就要比较他们的children了。 updateChildrenchildren分为老的children和新的children，分别为这两队children设置头尾指针，称为oldStartIdx,oldEndIdx,newStartIdx和newEndIdx。 两两比较，四种情况： 老头=新头 老头=新尾 新头=老尾 新尾=老尾 第一种情况，直接patchVnode（又回到四种的情况），新头++，老头++。 第二种情况，patchVnode，同时将老头放到老尾后。老头++，新尾–。 第三种情况，patchVnode，同时将老尾放到老头前。新头++，老尾–。 第四种情况，直接patchVnode。老尾–，新尾–。 如果以上情况都不符合。那么会从map中去找，map是一个以oldVnode的key为key，index为value的map。 先取出newStartIdx对应的vnode，获得它的key，然后去map里看有没有这个key，如果有的话，patchVnode并移动DOM节点。移动的方式是将这个oldVnode节点移到oldStartIdx对应的节点前。然后newStartIdx++。如果没有对应的key的话，会创建一个新的节点，插入到oldStartIdx对应的节点前。然后newStartIdx++。 这样遍历完后，要么newStartIdx &gt; newEndIdx，表示新的先遍历完，那就删除oldVnodes中oldStartIdx至oldEndIdx部分；要么oldStartIdx &gt; oldEndIDx，表示老的先遍历完，那就把新的还没遍历过的那段concat到oldVnodes后。 如果不是sameNode说明不值得比较，新的vnode直接代替老的vnode。 12345678const oEl = oldVnode.el // 获得老的ellet parentEle = api.parentNode(oEl) // 获得老的vnode对应DOM节点的父元素createEle(vnode) // 创建新vnode的DOM节点if (parentEle !== null) { api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 插入DOM api.removeChild(parentEle, oldVnode.el) // 移除老的DOM元素 oldVnode = null} 流程图总结 引用解析vue2.0的diff算法","link":"/2019/03/04/Vue-diff-算法/"},{"title":"Hello Blog!","text":"1.博客的诞生几天前在知乎上看见了一篇搭建博客的文章,寒假里也有搭建博客的想法，但是因为服务器和域名的门槛太高就搁置了，但是这篇文章中 hexo + github 的方法还是很简单的。 最重要的是可以自己设置界面，不像网易博客或者微博，有很大的自主权限。 2.项目中的技术github的使用，git版本控制和shell命令行模式的使用，HTML + CSS + JavaScript，SSH key，hexo框架，markdown。 2017.3.4 更新 markdown语法熟悉，老师要求需求等一系列文档用md格式 推荐编辑软件Typora 3.从项目中的收获因为有教程，一步一步来不会出太大差错。主要踩坑的地方就是_config.yml文件的配置。 1.图床。博客的头像以及文章中的图片都需要放置在云上，通过url获取，因为github空间有限制。 2.社交媒体的导航。也采用url的形式，例如weibo.com/username 3.打赏功能。收款的二维码图片在支付宝二维码平台获取 4.网站icon。favicon是网站的图标，应该放在source文件夹中。icon的大小为16 16或32 32。后缀名可以是ico或png，可以通过在线icon制作网站，如bitbug来转换。 5.github的使用。fork 别人的项目。 repository 代码仓库。pull request 提交代码请求","link":"/2017/03/01/关于此博客/"}],"tags":[{"name":"生活","slug":"生活","link":"/tags/生活/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"记录","slug":"记录","link":"/tags/记录/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"随想","slug":"随想","link":"/tags/随想/"},{"name":"Microservice","slug":"Microservice","link":"/tags/Microservice/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"前端","slug":"前端","link":"/tags/前端/"}],"categories":[]}